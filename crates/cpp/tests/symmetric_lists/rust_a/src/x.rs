// Generated by `wit-bindgen` 0.30.0. DO NOT EDIT!
// Options used:
#[allow(dead_code)]
pub mod test {
    #[allow(dead_code)]
    pub mod test {
        #[allow(dead_code, clippy::all)]
        pub mod i {
            #[used]
            #[doc(hidden)]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;

            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            pub fn f(a: &[_rt::String]) -> _rt::Vec<_rt::String> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<u8>; 2 * core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2 * core::mem::size_of::<*const u8>()],
                    );
                    let vec1 = a;
                    let len1 = vec1.len();
                    let layout1 = _rt::alloc::Layout::from_size_align_unchecked(
                        vec1.len() * (2 * core::mem::size_of::<*const u8>()),
                        core::mem::size_of::<*const u8>(),
                    );
                    let result1 = if layout1.size() != 0 {
                        let ptr = _rt::alloc::alloc(layout1).cast::<u8>();
                        if ptr.is_null() {
                            _rt::alloc::handle_alloc_error(layout1);
                        }
                        ptr
                    } else {
                        ::core::ptr::null_mut()
                    };
                    for (i, e) in vec1.into_iter().enumerate() {
                        let base = result1.add(i * (2 * core::mem::size_of::<*const u8>()));
                        {
                            let vec0 = e;
                            let ptr0 = vec0.as_ptr().cast::<u8>();
                            let len0 = vec0.len();
                            *base.add(core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
                            *base.add(0).cast::<*mut u8>() = ptr0.cast_mut();
                        }
                    }
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[link(wasm_import_module = "test:test/i")]
                    extern "C" {
                        #[cfg_attr(target_arch = "wasm32", link_name = "f")]
                        fn testX3AtestX2FiX00f(_: *mut u8, _: usize, _: *mut u8);
                    }
                    testX3AtestX2FiX00f(result1, len1, ptr2);
                    _rt::alloc::dealloc(result1, layout1);
                    let l3 = *ptr2.add(0).cast::<*mut u8>();
                    let l4 = *ptr2.add(core::mem::size_of::<*const u8>()).cast::<usize>();
                    let base8 = l3;
                    let len8 = l4;
                    let mut result8 = _rt::Vec::with_capacity(len8);
                    for i in 0..len8 {
                        let base = base8.add(i * (2 * core::mem::size_of::<*const u8>()));
                        let e8 = {
                            let l5 = *base.add(0).cast::<*mut u8>();
                            let l6 = *base.add(core::mem::size_of::<*const u8>()).cast::<usize>();
                            let len7 = l6;
                            let bytes7 = if len7 > 0 {
                                _rt::Vec::from_raw_parts(l5.cast(), len7, len7)
                            } else {
                                Default::default()
                            };

                            _rt::string_lift(bytes7)
                        };
                        result8.push(e8);
                    }
                    _rt::cabi_dealloc(
                        base8,
                        len8 * (2 * core::mem::size_of::<*const u8>()),
                        core::mem::size_of::<*const u8>(),
                    );
                    result8
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn g(a: &[u8]) -> _rt::Vec<u8> {
                unsafe {
                    #[cfg_attr(target_pointer_width = "64", repr(align(8)))]
                    #[cfg_attr(target_pointer_width = "32", repr(align(4)))]
                    struct RetArea(
                        [::core::mem::MaybeUninit<u8>; 2 * core::mem::size_of::<*const u8>()],
                    );
                    let mut ret_area = RetArea(
                        [::core::mem::MaybeUninit::uninit(); 2 * core::mem::size_of::<*const u8>()],
                    );
                    let vec0 = a;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let ptr1 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[link(wasm_import_module = "test:test/i")]
                    extern "C" {
                        #[cfg_attr(target_arch = "wasm32", link_name = "g")]
                        fn testX3AtestX2FiX00g(_: *mut u8, _: usize, _: *mut u8);
                    }
                    testX3AtestX2FiX00g(ptr0.cast_mut(), len0, ptr1);
                    let l2 = *ptr1.add(0).cast::<*mut u8>();
                    let l3 = *ptr1.add(core::mem::size_of::<*const u8>()).cast::<usize>();
                    let len4 = l3;
                    _rt::Vec::from_raw_parts(l2.cast(), len4, len4)
                }
            }
        }
    }
}
mod _rt {
    pub use alloc_crate::alloc;
    pub use alloc_crate::string::String;
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr, layout);
    }
    extern crate alloc as alloc_crate;
}

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.30.0:test:test:x:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 194] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07K\x01A\x02\x01A\x02\x01\
B\x06\x01ps\x01@\x01\x01a\0\0\0\x04\0\x01f\x01\x01\x01p}\x01@\x01\x01a\x02\0\x02\
\x04\0\x01g\x01\x03\x03\x01\x0btest:test/i\x05\0\x04\x01\x0btest:test/x\x04\0\x0b\
\x07\x01\0\x01x\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0dwit-component\
\x070.216.0\x10wit-bindgen-rust\x060.30.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen::rt::maybe_link_cabi_realloc();
}
